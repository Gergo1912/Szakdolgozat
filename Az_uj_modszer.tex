\chapter{Az új módszer}
Az új algoritmus alapját a \ref{makespanKod} ábrán látható makespan minimalizáló algoritmus képezi. Az újonnan létrehozott algoritmus korlátját már nem a makespan adja, hanem a jövedelmek. További változtatás, hogy egy taszkot nem csak egy berendezés tud végrehajtani, hanem a különböző kapacitású berendezések képesek az adott taszkokat párhuzamosan is végezni. A függvényt \aref{parhuzamos}. algoritmus mutatja be.

Az algoritmus bemenetét az időhorizont ($TH$), valamint a batch méret adja. Első lépésként a $profit^{cb}$ értékét inicializálja mínusz végtelennel, mert ennél biztosan nagyobb lesz a profit megoldható probléma esetén. A $SOAA$ halmaz kezdetben nem tartalmaz értéket, később futás során azok a berendezések lesznek benne, amelyek már hozzá vannak rendelve egy adott taszkhoz. A \textbf{recipe} függvény ugyanúgy, ahogy a makespan minimalizáló algoritmus esetében van, visszaadja a $G(N,A_1,A_2,w)$ által jelzett probléma receptgráfját, ahol
\begin{itemize}
  \item[] $N$: taszkokat és termékeket reprezentáló csomópontok halmaza	
  \item[] $A_1$: a receptélek halmaza
  \item[] $A_2$: ütemezési élek halmaza, ebben a pillanatban még üres
  \item[] $w_{i,i'}$: receptélek súlya, ami az $i$ taszk minimális feldolgozási ideje.
\end{itemize} 

A \textbf{select\_remove} függvény kiválaszt egy tetszőleges részproblémát. Ezzel egyidejűleg az $S$-ből kikerül a kiválasztott részprobléma. A kiválasztott részprobléma a $PP$ változóba kerül a következő formában  $(G(N,A_1,A_2,w),I',J',{\cal A})$, ahol 
\begin{itemize}
  \item[] $(G(N,A_1,A_2,w)$: az ütemezési gráf	
  \item[] $I'$: a nem ütemezett taszkok halmaza
  \item[] $J'$: azon berendezések halmaza, amelyeket lehet még taszkokhoz rendelni
  \item[] ${\cal A}$: taszk-berendezés hozzárendelések $(i,j)$ párok formájában.
\end{itemize}

Ezek után az algoritmus megvizsgálja a kiválasztott részproblémát a \textit{Feasible} függvény segítségével. Ez megnézi, hogy a részprobléma a megadott időhorizonton belül megvalósítható-e? Ha igen, akkor megvizsgálja az algoritmus, hogy a részprobléma által nyújtott legnagyobb elérhető jövedelem nagyobb-e, mint az eddig megtalált legjobb megoldás. Ha valamelyik feltételnek nem felel meg a részprobléma, akkor az iteráció ezen lépése véget ér, és egy másik részprobléma kerül kiválasztásra, amennyiben még van ilyen.

Ha mindkét feltételnek megfelel a részprobléma, akkor megnézi az algoritmus, hogy levél-e. Ez azt jelenti, hogy található-e még olyan berendezés, amelyet lehet taszkhoz rendelni. Abban ez esetben ha nincs ilyen berendezés ($J'== \emptyset$), azaz a probléma levélnek minősül, akkor a jelenlegi legjobb megoldás ($profit^{cb}$) értéke felülíródik a vizsgált részprobléma által nyújtott megoldással. Ha viszont nem levél, akkor egy berendezés kerül kiválasztásra a még elérhető berendezések halmazából. A kiválasztott $j$ berendezéshez az algoritmus hozzárendeli az összes olyan lehetséges taszkot, ami még nem volt korábban hozzárendelve. Minden ilyen taszkhoz készül egy másolat a jelenlegi S-gráfról, ami kiegészül az új hozzárendelésekkel.

Azon taszkok esetében, amelyeket még egy berendezés sem végez, viszont a kiválasztott $j$ berendezésen kívül más berendezés is meg tud oldani, olyan döntés is születhet, hogy az adott berendezés nem is fogja azt elvégezni. Ilyenkor az $S$ halmaz kibővül egy olyan részproblémával, ahol a $j$ berendezés már nem végez több taszkot. 

Az ütemezés elvégeztével az algoritmus visszatér a megtalált legjobb megoldással, vagyis az elérhető legnagyobb bevétel értékével.

\newpage
\underline{Az algoritmus változóinak elnevezése a következő:}
\begin{itemize}
	\item $profit^{cb}$: a megtalált legjobb megoldás
	\item $SOAA$ (Set Of Already Assigned): azon taszkok halmaza, amelyek már hozzá vannak rendelve az adott berendezéshez
	\item $S$: a nyitott részproblémák halmaza
	\item $PP$: az aktuális részprobléma
	\item $I$: a taszkok halmaza
	\item $J$: a berendezések halmaza
	\item $TH$: az időhorizont
	\item $A$: az élek halmaz
	\item $w$: a receptél súlya
	\item $profit\_bound$: a kiválasztott részprobléma profit korlátja.
\end{itemize}

\underline{Az algoritmusban meghívott függvények:}
\begin{itemize}
	\item \textit{recipe}: egy receptgráfot ad vissza
	\item \textit{select\_remove}: kiválaszt egy részproblémát valamilyen módszer alapján
	\item \textit{Feasible}: megmutatja, hogy a részprobléma a megadott időhorizonton belül megoldható-e
	\item \textit{IsLeaf}: megmutatja, hogy a részprobléma levélnek minősül-e ($J'==\emptyset$).
\end{itemize}

\begin{algorithm}[H]
\caption{Párhuzamos taszkvégrehajtást megvalósító algoritmus}
\label{parhuzamos}
\begin{algorithmic}[1]
\Procedure{Maxprofit}{TH,batch\_number}
	\State $profit^{cb}:= -\infty$
	\State $SOAA:= \emptyset$
	\State $S:= {(recipe(),I,J,\emptyset)}$
	\While{$S \neq \emptyset$}
		\State $PP:= select\_remove(S)$
		\If {$PP.Feasible(TH)$}
			\If{$PP.proift\_bound > profit^{cb}$}
				\If{$PP.IsLeaf()$}
					\State $profit^{cb}:=PP.profit\_bound$
				\Else
					\State $j:=select(J')$
					\ForAll	{$i \in I_j \setminus SOAA$}
						\State $SOAA_j: = SOAA_j\cup i$
						\State $G^i(N,A_1^i,A_2^i,w^i):= G(N,A_1,A_2,w)$
						\ForAll	{$i' \in \bigcup_{(i',j) \in {\cal A}} I_{i^i}^+  \setminus \{i\} $}
							\State $A_2^i:= A_2^i \cup \{(i',i)\}$				
						\EndFor
						\ForAll {$ i' \in I_i^+$}
							\State $w_{i,i'}^i:= t_{i,j}^{pr}$
						\EndFor
						\State $S:= S \cup (G^i(N,A_1,A_2^i,w^i),I,J',{\cal A} \cup \{(i,j)\})$
					\EndFor
					\If {$I_j \setminus \bigcup_{j \in J} SOAA_j \subseteq \bigcup_{j != j', j'\in J'} I_{j'}$}
						\State $S:= S \cup (G(N,A_1,A_2),I,J'\setminus\{j\},{\cal A})$
					\EndIf					
				\EndIf
			\EndIf
		\EndIf
	\EndWhile
	\State \Return $profit^{cb}$
\EndProcedure
\end{algorithmic}
\end{algorithm}